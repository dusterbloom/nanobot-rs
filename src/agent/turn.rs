//! Canonical message representation — independent of any LLM wire format.
//!
//! `Turn` is the single source of truth for conversation history. It is stored
//! in session JSONL and in memory. Wire-format rendering (OpenAI / Anthropic /
//! local-alternation) happens at call time via `ConversationProtocol::render()`.
//!
//! ## Why not store OpenAI JSON?
//!
//! Storing wire format forces every consumer (agent_loop, tool_runner, subagent,
//! LcmEngine) to be aware of protocol differences, leading to scattered `is_local`
//! checks and `repair_*` mutation passes. With canonical `Turn` storage, each
//! protocol renders correctly from clean data — no repair needed.

use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

// ─────────────────────────────────────────────────────────────
// Core types
// ─────────────────────────────────────────────────────────────

/// A media attachment (image, audio, etc.) carried by a user turn.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct MediaAttachment {
    pub mime_type: String,
    /// Base64-encoded content.
    pub data: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// A structured tool invocation produced by an LLM.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ToolCall {
    /// Unique call ID — generated by us, stable across renders.
    pub id: String,
    /// Tool name (matches `Tool::name()`).
    pub tool: String,
    /// Arguments as a JSON object.
    pub args: Value,
}

/// Canonical conversation turn.
///
/// Stored in session JSONL (`kind` tag discriminant, snake_case).
/// Rendered to wire format by `ConversationProtocol::render()`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "kind", rename_all = "snake_case")]
pub enum Turn {
    /// A message from the human / end-user.
    User {
        content: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        media: Vec<MediaAttachment>,
    },

    /// A response from the assistant model, optionally with tool invocations.
    Assistant {
        #[serde(skip_serializing_if = "Option::is_none")]
        text: Option<String>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        tool_calls: Vec<ToolCall>,
    },

    /// The result of executing a tool call.
    ToolResult {
        /// Matches the `ToolCall::id` that produced this result.
        call_id: String,
        /// Tool name for display / debugging.
        tool: String,
        /// Textual result (may be truncated by the registry).
        result: String,
        /// Whether the tool execution succeeded.
        ok: bool,
    },

    /// Injected system context — rendered at position 0 in the wire format.
    /// Never persisted to session JSONL; reconstructed from workspace files each turn.
    System { content: String },

    /// An LCM-produced summary replacing a block of older turns.
    /// Persisted inline in session JSONL so the SummaryDag survives restarts.
    Summary {
        text: String,
        /// MessageIds from `LcmEngine::store` covered by this summary.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        source_ids: Vec<usize>,
        /// Compaction level (1 = preserve_details, 2 = bullet_points, 3 = deterministic).
        level: u8,
    },
}

impl Turn {
    /// Returns true if this turn carries an assistant response (text or tool calls).
    pub fn is_assistant(&self) -> bool {
        matches!(self, Turn::Assistant { .. })
    }

    /// Returns true if this is a user turn (not system, not tool result).
    pub fn is_user(&self) -> bool {
        matches!(self, Turn::User { .. })
    }

    /// Returns true if this is a summary turn (LCM compaction output).
    pub fn is_summary(&self) -> bool {
        matches!(self, Turn::Summary { .. })
    }

    /// Returns the assistant text content, if any.
    pub fn assistant_text(&self) -> Option<&str> {
        if let Turn::Assistant { text, .. } = self {
            text.as_deref()
        } else {
            None
        }
    }

    /// Returns tool calls from an assistant turn.
    pub fn tool_calls(&self) -> &[ToolCall] {
        if let Turn::Assistant { tool_calls, .. } = self {
            tool_calls
        } else {
            &[]
        }
    }

    /// Returns true if this turn should be persisted to session JSONL.
    /// `Turn::System` is reconstructed each turn and is never stored.
    pub fn is_persistable(&self) -> bool {
        !matches!(self, Turn::System { .. })
    }

    /// Convert a `Turn::Summary` to a JSON Value for session storage.
    ///
    /// Returns `None` if the turn is not a summary.
    pub fn summary_to_json(&self) -> Option<Value> {
        if let Turn::Summary { text, source_ids, level } = self {
            Some(json!({
                "role": "summary",
                "text": text,
                "source_ids": source_ids,
                "level": level,
            }))
        } else {
            None
        }
    }
}

// ─────────────────────────────────────────────────────────────
// Legacy conversion (OpenAI wire format → Turn)
// ─────────────────────────────────────────────────────────────

/// Convert a legacy OpenAI-format message `Value` → `Turn`.
///
/// Used when loading old sessions that predate the `Turn` format.
/// Returns `None` for unrecognised or structurally invalid messages.
pub fn turn_from_legacy(v: &Value) -> Option<Turn> {
    let role = v.get("role").and_then(|r| r.as_str())?;
    match role {
        "user" => {
            let content = v
                .get("content")
                .and_then(|c| c.as_str())
                .unwrap_or("")
                .to_string();
            Some(Turn::User { content, media: vec![] })
        }
        "assistant" => {
            let text = v
                .get("content")
                .and_then(|c| c.as_str())
                .filter(|s| !s.is_empty())
                .map(|s| s.to_string());

            let tool_calls = v
                .get("tool_calls")
                .and_then(|tc| tc.as_array())
                .map(|arr| arr.iter().filter_map(parse_legacy_tool_call).collect())
                .unwrap_or_default();

            Some(Turn::Assistant { text, tool_calls })
        }
        "tool" => {
            let call_id = v
                .get("tool_call_id")
                .and_then(|id| id.as_str())
                .unwrap_or("")
                .to_string();
            let tool = v
                .get("name")
                .and_then(|n| n.as_str())
                .unwrap_or("unknown")
                .to_string();
            let result = v
                .get("content")
                .and_then(|c| c.as_str())
                .unwrap_or("")
                .to_string();
            Some(Turn::ToolResult { call_id, tool, result, ok: true })
        }
        "system" => {
            let content = v
                .get("content")
                .and_then(|c| c.as_str())
                .unwrap_or("")
                .to_string();
            Some(Turn::System { content })
        }
        "summary" => {
            // LCM summary entry persisted in session JSONL.
            let text = v
                .get("text")
                .and_then(|t| t.as_str())
                .unwrap_or("")
                .to_string();
            let source_ids = v
                .get("source_ids")
                .and_then(|ids| ids.as_array())
                .map(|arr| arr.iter().filter_map(|v| v.as_u64().map(|n| n as usize)).collect())
                .unwrap_or_default();
            let level = v
                .get("level")
                .and_then(|l| l.as_u64())
                .map(|n| n as u8)
                .unwrap_or(1);
            Some(Turn::Summary { text, source_ids, level })
        }
        _ => None,
    }
}

/// Parse a single tool_call entry from a legacy assistant message.
fn parse_legacy_tool_call(tc: &Value) -> Option<ToolCall> {
    let id = tc.get("id").and_then(|v| v.as_str())?.to_string();
    let func = tc.get("function")?;
    let tool = func.get("name").and_then(|n| n.as_str())?.to_string();

    // Arguments are stored as a JSON string in the wire format.
    let args: Value = match func.get("arguments").and_then(|a| a.as_str()) {
        Some(s) => serde_json::from_str(s).unwrap_or(Value::Object(Default::default())),
        None => Value::Object(Default::default()),
    };

    Some(ToolCall { id, tool, args })
}

// ─────────────────────────────────────────────────────────────
// Tests
// ─────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn user_round_trips() {
        let t = Turn::User { content: "hello".into(), media: vec![] };
        let s = serde_json::to_string(&t).unwrap();
        let t2: Turn = serde_json::from_str(&s).unwrap();
        assert_eq!(t, t2);
    }

    #[test]
    fn assistant_with_tool_calls_round_trips() {
        let t = Turn::Assistant {
            text: Some("ok".into()),
            tool_calls: vec![ToolCall {
                id: "tc_1".into(),
                tool: "read_file".into(),
                args: json!({"path": "Cargo.toml"}),
            }],
        };
        let s = serde_json::to_string(&t).unwrap();
        let t2: Turn = serde_json::from_str(&s).unwrap();
        assert_eq!(t, t2);
    }

    #[test]
    fn tool_result_round_trips() {
        let t = Turn::ToolResult {
            call_id: "tc_1".into(),
            tool: "exec".into(),
            result: "stdout output".into(),
            ok: true,
        };
        let s = serde_json::to_string(&t).unwrap();
        let t2: Turn = serde_json::from_str(&s).unwrap();
        assert_eq!(t, t2);
    }

    #[test]
    fn summary_round_trips() {
        let t = Turn::Summary {
            text: "Earlier context summary.".into(),
            source_ids: vec![0, 1, 2],
            level: 1,
        };
        let s = serde_json::to_string(&t).unwrap();
        let t2: Turn = serde_json::from_str(&s).unwrap();
        assert_eq!(t, t2);
    }

    #[test]
    fn kind_tag_is_snake_case() {
        let cases: &[(Turn, &str)] = &[
            (Turn::User { content: "x".into(), media: vec![] }, "user"),
            (Turn::Assistant { text: None, tool_calls: vec![] }, "assistant"),
            (Turn::ToolResult { call_id: "x".into(), tool: "t".into(), result: "r".into(), ok: true }, "tool_result"),
            (Turn::System { content: "s".into() }, "system"),
            (Turn::Summary { text: "s".into(), source_ids: vec![], level: 1 }, "summary"),
        ];
        for (turn, expected_kind) in cases {
            let v = serde_json::to_value(turn).unwrap();
            assert_eq!(v["kind"], *expected_kind, "wrong kind for {:?}", turn);
        }
    }

    #[test]
    fn system_is_not_persistable() {
        assert!(!Turn::System { content: "prompt".into() }.is_persistable());
        assert!(Turn::User { content: "x".into(), media: vec![] }.is_persistable());
        assert!(Turn::Assistant { text: None, tool_calls: vec![] }.is_persistable());
        assert!(Turn::Summary { text: "s".into(), source_ids: vec![], level: 1 }.is_persistable());
    }

    #[test]
    fn legacy_user_converts() {
        let v = json!({"role": "user", "content": "hello"});
        let t = turn_from_legacy(&v).unwrap();
        assert!(matches!(t, Turn::User { .. }));
        if let Turn::User { content, .. } = t {
            assert_eq!(content, "hello");
        }
    }

    #[test]
    fn legacy_assistant_text_converts() {
        let v = json!({"role": "assistant", "content": "Hi there."});
        let t = turn_from_legacy(&v).unwrap();
        if let Turn::Assistant { text, tool_calls } = t {
            assert_eq!(text.as_deref(), Some("Hi there."));
            assert!(tool_calls.is_empty());
        } else {
            panic!("expected assistant");
        }
    }

    #[test]
    fn legacy_assistant_with_tool_calls_converts() {
        let v = json!({
            "role": "assistant",
            "content": "",
            "tool_calls": [{
                "id": "tc_abc",
                "type": "function",
                "function": {
                    "name": "exec",
                    "arguments": "{\"cmd\": \"ls -la\"}"
                }
            }]
        });
        let t = turn_from_legacy(&v).unwrap();
        if let Turn::Assistant { tool_calls, .. } = t {
            assert_eq!(tool_calls.len(), 1);
            assert_eq!(tool_calls[0].id, "tc_abc");
            assert_eq!(tool_calls[0].tool, "exec");
            assert_eq!(tool_calls[0].args["cmd"], "ls -la");
        } else {
            panic!("expected assistant with tool_calls");
        }
    }

    #[test]
    fn legacy_tool_result_converts() {
        let v = json!({
            "role": "tool",
            "tool_call_id": "tc_abc",
            "name": "exec",
            "content": "file1\nfile2"
        });
        let t = turn_from_legacy(&v).unwrap();
        if let Turn::ToolResult { call_id, tool, result, ok } = t {
            assert_eq!(call_id, "tc_abc");
            assert_eq!(tool, "exec");
            assert_eq!(result, "file1\nfile2");
            assert!(ok);
        } else {
            panic!("expected tool_result");
        }
    }

    #[test]
    fn legacy_system_converts() {
        let v = json!({"role": "system", "content": "You are helpful."});
        let t = turn_from_legacy(&v).unwrap();
        assert!(matches!(t, Turn::System { .. }));
    }

    #[test]
    fn legacy_unknown_role_returns_none() {
        let v = json!({"role": "unknown", "content": "?"});
        assert!(turn_from_legacy(&v).is_none());
    }

    #[test]
    fn empty_tool_calls_omitted_from_json() {
        // Vec::is_empty guard — no "tool_calls":[] noise in JSONL
        let t = Turn::Assistant { text: Some("hi".into()), tool_calls: vec![] };
        let v = serde_json::to_value(&t).unwrap();
        assert!(v.get("tool_calls").is_none(), "empty tool_calls should be omitted");
    }

    #[test]
    fn empty_media_omitted_from_json() {
        let t = Turn::User { content: "hi".into(), media: vec![] };
        let v = serde_json::to_value(&t).unwrap();
        assert!(v.get("media").is_none(), "empty media should be omitted");
    }

    #[test]
    fn is_summary_detects_summary_turn() {
        let summary = Turn::Summary {
            text: "Context covered.".into(),
            source_ids: vec![0, 1, 2],
            level: 1,
        };
        assert!(summary.is_summary());
        assert!(!Turn::User { content: "hi".into(), media: vec![] }.is_summary());
    }

    #[test]
    fn summary_to_json_produces_role_summary() {
        let summary = Turn::Summary {
            text: "Earlier context summary.".into(),
            source_ids: vec![0, 1, 2],
            level: 2,
        };
        let v = summary.summary_to_json().unwrap();
        assert_eq!(v["role"], "summary");
        assert_eq!(v["text"], "Earlier context summary.");
        assert_eq!(v["source_ids"], json!([0, 1, 2]));
        assert_eq!(v["level"], 2);
    }

    #[test]
    fn non_summary_to_json_returns_none() {
        let user = Turn::User { content: "hi".into(), media: vec![] };
        assert!(user.summary_to_json().is_none());
    }

    #[test]
    fn legacy_summary_converts_to_turn_summary() {
        let v = json!({
            "role": "summary",
            "text": "Messages 1-10 covered: X, Y, Z.",
            "source_ids": [0, 1, 2, 3],
            "level": 1
        });
        let t = turn_from_legacy(&v).unwrap();
        if let Turn::Summary { text, source_ids, level } = t {
            assert!(text.contains("Messages 1-10"));
            assert_eq!(source_ids.len(), 4);
            assert_eq!(level, 1);
        } else {
            panic!("expected Turn::Summary");
        }
    }
}
